use std::{
    fs::File,
    io::{BufRead, BufReader},
    time::Duration,
};

use reqwest::StatusCode;

use crate::{http_client::RetryClient, CveDb};

enum Scheme {
    File,
    Http,
}

pub struct CveReader {
    uri: String,
    scheme: Scheme,
}

fn parse_uri(uri: &str) -> Option<(Scheme, String)> {
    if uri.starts_with("http") {
        return Some((Scheme::Http, uri.to_owned()));
    }
    if uri.starts_with("file:") {
        return Some((Scheme::File, uri.replace("file://", "").to_owned()));
    }
    None
}

impl CveReader {
    /// create a reader, reading at the adress provided
    /// Supported address are
    /// - file://
    /// - https://
    /// - http://
    pub fn create(uri: &str) -> Option<Self> {
        parse_uri(uri).map(|(scheme, uri)| Self { uri, scheme })
    }

    fn format_product_path_local(&self, name: &str, version: &str) -> String {
        self.uri.clone() + &CveDb::end_format_product_path(name, version)
    }

    fn format_product_path_http(&self, name: &str, version: &str) -> String {
        self.uri.clone() + &CveDb::end_format_product_path(name, version)
    }

    fn get_cves_by_cots_local(&self, name: &str, versions: Vec<&str>) -> Vec<Vec<String>> {
        let v = versions.clone();
        v.iter()
            .flat_map(move |version| {
                let path = self.format_product_path_local(name, version.to_owned());
                println!("reading local: {}", &path);
                let f = File::options().read(true).open(path);
                return match f {
                    Ok(file) => {
                        let reader = BufReader::new(&file);
                        let e = reader
                            .lines()
                            .map(|e| e.unwrap())
                            .map(|e| e.split(' ').next().unwrap().to_owned())
                            .collect::<Vec<_>>();
                        Some(e)
                    }
                    Err(_) => None,
                };
            })
            .collect::<Vec<_>>()
    }

    fn get_cves_by_cots_http(&self, name: &str, versions: Vec<&str>) -> Vec<Vec<String>> {
        let client = RetryClient::create(
            RetryClient::get_default_client(),
            Duration::from_secs(5),
            vec![StatusCode::OK, StatusCode::NOT_FOUND],
        );
        versions
            .iter()
            .filter_map(move |version| {
                let path = self.format_product_path_http(name, version.to_owned());
                let (status, reader) = client.get_response(&path);
                if status == StatusCode::OK {
                    let e = reader
                        .lines()
                        .map(|e| e.unwrap())
                        .map(|e| e.split(' ').next().expect("Malformed input").to_owned())
                        .collect::<Vec<_>>();
                    return Some(e);
                }
                None
            })
            .collect::<Vec<_>>()
    }

    /// will return the cve names according to the cots and the versions
    pub fn get_cves_by_cots(&self, name: &str, versions: Vec<&str>) -> Option<Vec<String>> {
        let it = match self.scheme {
            Scheme::File => self.get_cves_by_cots_local(name, versions),
            Scheme::Http => self.get_cves_by_cots_http(name, versions),
        };
        let results = it.iter().flat_map(|e| e.to_owned()).collect::<Vec<_>>();
        if results.is_empty() {
            return None;
        }
        Some(results)
    }
}
