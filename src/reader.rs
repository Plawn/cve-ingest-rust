use std::{
    fs::File,
    io::{BufRead, BufReader},
    time::Duration,
};

use reqwest::StatusCode;

use crate::http_client::RetryClient;

enum Scheme {
    FILE,
    HTTP,
    // GITHUB,
}

pub struct CveReader {
    uri: String,
    scheme: Scheme,
}

fn parse_uri(uri: &str) -> Option<(Scheme, String)> {
    if uri.starts_with("https://github.com/") {
        // https://github.com/Plawn/cve-ingest-rust/tree/to-local
        // https://github.com/Plawn/cve-ingest-rust/
        // https://raw.githubusercontent.com/Plawn/cve-ingest-rust/master/Cargo.toml
        // https://raw.githubusercontent.com/Plawn/cve-ingest-rust/to-local/db/product/anyplace/-.cves-vendor
        // let r = format!("https://raw.githubusercontent.com/Plawn/cve-ingest-rust/to-local/db/")
        // return Some((Scheme::HTTP, "".to_owned()));
    }
    if uri.starts_with("http") {
        // https://raw.githubusercontent.com/Plawn/cve-ingest-rust/to-local/db/
        return Some((Scheme::HTTP, uri.to_owned()));
    }
    if uri.starts_with("file:") {
        return Some((Scheme::FILE, uri.replace("file://", "").to_owned()));
    }
    None
}

impl CveReader {
    pub fn at(uri: &str) -> Option<Self> {
        if let Some((scheme, uri)) = parse_uri(uri) {
            return Some(Self { uri, scheme });
        }
        None
    }

    fn format_product_path_local(&self, name: &str, version: &str) -> String {
        use urlencoding::encode;
        const extension: &str = ".cves-vendor";
        let base_folder = self.uri.clone() + "/product/" + &name + "/";
        let encoded = encode(version).into_owned();
        
        base_folder + &encoded + extension
    }

    fn format_product_path_http(&self, name: &str, version: &str) -> String {
        use urlencoding::encode;
        const extension: &str = ".cves-vendor";
        let base_folder = self.uri.clone() + "/product/" + &name + "/";
        let encoded = encode(version).into_owned();
        
        base_folder + &encoded + extension
    }

    fn get_cves_by_cots_local(&self, name: &str, versions: Vec<&str>) -> Vec<Vec<String>> {
        let v = versions.clone();
        v.iter()
            .flat_map(move |version| {
                let path = self.format_product_path_local(name, version.to_owned());
                let f = File::options().read(true).open(path);
                return match f {
                    Ok(file) => {
                        let reader = BufReader::new(&file);
                        let e = reader
                            .lines()
                            .map(|e| e.unwrap())
                            .map(|e| e.split(' ').next().unwrap().to_owned())
                            .collect::<Vec<_>>();
                        Some(e)
                    }
                    Err(_) => None,
                };
            })
            .collect::<Vec<_>>()
    }

    fn get_cves_by_cots_http(&self, name: &str, versions: Vec<&str>) -> Vec<Vec<String>> {
        let client = RetryClient::create(
            RetryClient::get_default_client(),
            Duration::from_secs(5),
            vec![StatusCode::OK, StatusCode::NOT_FOUND],
        );
        versions.iter()
            .filter_map(move |version| {
                let path = self.format_product_path_http(name, version.to_owned());
                println!("fetching: {}", &path);
                let (status, reader) = client.get_response(&path);
                if status == StatusCode::OK {
                    let e = reader
                        .lines()
                        .map(|e| e.unwrap())
                        .map(|e| e.split(' ').next().unwrap().to_owned())
                        .collect::<Vec<_>>();
                    return Some(e);
                }
                None
            })
            .collect::<Vec<_>>()
    }

    /// will return the cve names
    pub fn get_cves_by_cots(&self, name: &str, versions: Vec<&str>) -> Option<Vec<String>> {
        let it = match self.scheme {
            Scheme::FILE => self.get_cves_by_cots_local(name, versions),
            Scheme::HTTP => self.get_cves_by_cots_http(name, versions),
        };
        let results = it.iter().flat_map(|e| e.to_owned()).collect::<Vec<_>>();
        if results.is_empty() {
            return None;
        }
        Some(results)
    }
}
