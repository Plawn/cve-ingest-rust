use std::{
    fs::{self, File},
    ops::Sub,
};

use crate::{
    match_cpe::option_to_str,
    prepare_date,
    windowed::{UrlProvider, Windower},
    write_pretty_json_to_file, CveDb, Date, ScrollMode, Vulnerability, CVE,
};
use chrono::{DateTime, Duration, TimeZone, Utc};
use serde::{Deserialize, Serialize};

#[derive(Debug)]
pub struct Window {
    pub start: Date,
    pub end: Date,
}

/// split date interval
pub fn get_windows_until_now(s: DateTime<Utc>, window_size: Duration) -> Vec<Window> {
    let mut start = Utc::now();

    if start.sub(window_size) <= s {
        return vec![Window {
            end: start,
            start: s,
        }];
    }

    // si le dernier est moins que window size,
    // alors prendre juste la diff
    let mut res = vec![];
    while start > s {
        let end = start.sub(window_size); // today minus 30 days
        let w = Window {
            start: end,
            end: start,
        };
        res.push(w);
        start = end;
    }
    res.reverse();
    res
}

#[derive(Deserialize, Debug, Serialize)]
pub struct LastUdpateInfos {
    /// encoded as timestamp
    pub date: i64,
}

impl LastUdpateInfos {
    pub fn new(d: &Date) -> Self {
        Self {
            date: d.timestamp_millis(),
        }
    }
}

impl UrlProvider for Vulnerability {
    fn url(start: Option<Date>, end: Option<Date>, index: u32, api_key: &Option<String>) -> String {
        let url = format!(
            "https://services.nvd.nist.gov/rest/json/cves/2.0/?lastModStartDate={}&lastModEndDate={}&startIndex={}", 
                option_to_str(start.map(|e| prepare_date(&e))), option_to_str(end.map(|e| prepare_date(&e))), index);
        url
    }
}

impl CveDb {
    fn do_cve_window(&self, window: Option<&Window>) -> Result<(), Box<dyn std::error::Error>> {
        let size_hint = Some(2000);
        let w = Windower::<'_, _, Vulnerability>::new(
            window.map(|w| w.start),
            window.map(|w| w.end),
            "vulnerabilities".as_bytes(),
            None, // TODO: add api_key support
            size_hint,
        )
        .filter_map(|e| match e {
            Err(err) => {
                eprintln!("Failed to parse: {:?}", &err);
                None
            }
            Ok(v) => Some(v),
        });
        for cve in w.map(|e: Vulnerability| e.cve) {
            let prepared = CVE::from(&self.db, cve);
            let path = prepared.local_path(&self.folder);
            println!("writing to path: {}", path);
            write_pretty_json_to_file(&path, &prepared, None);
        }
        Ok(())
    }

    fn update_infos_filepath(&self) -> String {
        format!("{}/cves.json", self.folder)
    }

    fn set_cve_last_update(&self, date: &Date) {
        write_pretty_json_to_file(
            &self.update_infos_filepath(),
            &LastUdpateInfos::new(date),
            Some(true),
        )
    }

    fn get_cve_last_update(&self) -> Option<Date> {
        File::open(self.update_infos_filepath())
            .ok()
            .and_then(|file| {
                let parsed: LastUdpateInfos =
                    serde_json::from_reader(file).expect("failed to parse 'cve last update json'");
                return Date::from_timestamp_millis(parsed.date);
            })
    }

    /// Makes sure all cve directories exists
    fn ensure_dir_exists(&self) {
        // TODO: identify current year
        // start from 1999 -> add documentation to explain
        let years = 1999..2025;
        years.for_each(|y| {
            let path = format!("{}/cves/{}", &self.folder, y);
            fs::create_dir_all(&path).expect(&format!("failed to create folder '{}'", &path));
        });
    }
    // using date scroll mode
    pub fn update_cves(&self, mode: &ScrollMode, window_size: Option<Duration>) {
        match mode {
            ScrollMode::Page => todo!(),
            ScrollMode::Date => {
                self.ensure_dir_exists();
                let last_update = self.get_cve_last_update();
                let min = Utc.with_ymd_and_hms(2019, 1, 1, 0, 0, 0).unwrap();
                let d = last_update.unwrap_or(min);
                let window_size = window_size.unwrap_or(Duration::days(20));
                let windows = get_windows_until_now(d, window_size);
                for w in windows {
                    println!("doing {:?}", w);
                    self.do_cve_window(Some(&w)).expect("failed to do window");
                    self.set_cve_last_update(&w.start);
                }
            }
        }
    }
}
