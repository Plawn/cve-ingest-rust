use std::{fs::File, ops::Sub};

use crate::{prepare_date, CveDb, Date, Vulnerability, CVE};
use chrono::{DateTime, Duration, TimeZone, Utc};
use jsonit::{make_prefix, JsonSeqIterator};
use serde::{Deserialize, Serialize};

#[derive(Debug)]
pub struct Window {
    pub start: Date,
    pub end: Date,
}

impl Window {}

fn get_cve_url(window: &Window, start_index: u32) -> String {
    // let url = "https://services.nvd.nist.gov/rest/json/cves/2.0/?lastModStartDate=2023-10-29T13:32:53.000%2B01:00&lastModEndDate=2023-10-29T21:32:53.000%2B01:00&startIndex=0";
    let url = format!(
        "https://services.nvd.nist.gov/rest/json/cves/2.0/?lastModStartDate={}&lastModEndDate={}&startIndex={}", prepare_date(&window.start), prepare_date(&window.end), start_index);
    url
}

// split date interval
pub fn get_windows_until_now(s: DateTime<Utc>) -> Vec<Window> {
    let mut start = Utc::now();
    let window_size = Duration::days(25);

    if start.sub(window_size) <= s {
        return vec![Window {
            end: start,
            start: s,
        }];
    }

    // si le dernier est moins que window size,
    // alors prendre juste la diff
    let mut res = vec![];
    while start > s {
        let end = start.sub(window_size); // today minus 30 days
        let w = Window {
            start: end,
            end: start,
        };
        res.push(w);
        start = end;
    }
    res.reverse();
    res
}

#[derive(Deserialize, Debug, Serialize)]
pub struct LastUdpateInfos {
    /// encoded as timestamp
    pub date: i64,
}

impl LastUdpateInfos {
    pub fn new(d: Date) -> Self {
        Self {
            date: d.timestamp_millis(),
        }
    }
}

impl CveDb {
    fn do_cve_window(&self, w: &Window) -> Result<(), Box<dyn std::error::Error>> {
        let url = get_cve_url(w, 0);
        println!("{}", &url);
        let resp = reqwest::blocking::get(url)?;
        // iter on response
        let prefix = make_prefix("vulnerabilities");
        let it = JsonSeqIterator::new(resp, &prefix).map(|e| e.unwrap());
        for cve in it.map(|e: Vulnerability| e.cve) {
            let prepared = CVE::from(&self.db, cve);
            let path = prepared.local_path(&self.folder);
            let writer = File::options()
                .write(true)
                .open(path)
                .expect("failed to open file");
            serde_json::to_writer_pretty(writer, &prepared).expect("failed to serialyze");
        }
        Ok(())
    }

    fn update_infos_filepath(&self) -> String {
        format!("{}/cves.json", self.folder.to_string())
    }

    fn set_cve_last_update(&self, date: Date) {
        let f = File::open(self.update_infos_filepath()).unwrap();
        serde_json::to_writer_pretty(f, &LastUdpateInfos::new(date))
            .expect("failed to write db update");
    }

    fn get_cve_last_update(&self) -> Option<Date> {
        let c = File::open(self.update_infos_filepath()).unwrap();
        let parsed: LastUdpateInfos = serde_json::from_reader(c).expect("failed to parse");
        Date::from_timestamp_millis(parsed.date)
    }

    pub fn update_cves(&self) {
        let last_update = self.get_cve_last_update();
        let min = Utc.with_ymd_and_hms(1970, 1, 1, 0, 0, 0).unwrap();
        let d = last_update.unwrap_or(min);
        let windows = get_windows_until_now(d);
        for w in windows {
            self.do_cve_window(&w).expect("failed to do window");
            self.set_cve_last_update(w.start);
            println!("did {:?}", w);
        }
        // get last date
        // for each windows
        // do window
        // update last update
        todo!();
    }
}
