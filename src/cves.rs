use std::{
    fs::File, io::{Read, Write}, ops::Sub, str::FromStr
};

use crate::{match_cpe::MatchString2, prepare_date, CveDb, Date, NVDCve, Root, Vulnerability, CVE};
use chrono::{DateTime, Days, Duration, TimeZone, Utc};
use jsonit::{make_prefix, JsonSeqIterator};
use serde::{de::DeserializeOwned, Deserialize, Serialize};

#[derive(Debug)]
pub struct Window {
    pub start: Date,
    pub end: Date,
}


fn get_cve_url(window: &Window, start_index: u32) -> String {
    // let url = "https://services.nvd.nist.gov/rest/json/cves/2.0/?lastModStartDate=2023-10-29T13:32:53.000%2B01:00&lastModEndDate=2023-10-29T21:32:53.000%2B01:00&startIndex=0";
    let url = format!(
        "https://services.nvd.nist.gov/rest/json/cves/2.0/?lastModStartDate={}&lastModEndDate={}&startIndex={}", prepare_date(&window.start), prepare_date(&window.end), start_index);
    url
}

// split date interval
pub fn get_windows_until_now(s: DateTime<Utc>) -> Vec<Window> {
    let mut start = Utc::now().sub(Duration::hours(5));
    let mut res = vec![];
    while start > s {
        let end = start.checked_sub_signed(Duration::days(25)).unwrap(); // today minus 30 days
        let w = Window { start: end, end: start };
        res.push(w);
        start = end;
    }
    res.reverse();
    res
}

#[derive(Deserialize, Debug, Serialize)]
pub struct LastUdpateInfos {
    /// encoded as timestamp
    pub date: i64,
}

impl LastUdpateInfos {
    pub fn new(d: Date) -> Self {
        Self {
            date: d.timestamp_millis(),
        }
    }
}

impl CveDb {
    fn do_cve_window(&self, w: &Window) -> Result<(), Box<dyn std::error::Error>> {
        let url = get_cve_url(w, 0);
        println!("{}", &url);
        let resp = reqwest::blocking::get(url)?;
        // iter on response
        let prefix = make_prefix("vulnerabilities");
        let it = JsonSeqIterator::new(resp, &prefix).map(|e| e.unwrap());
        for cve in it.map(|e: Vulnerability| e.cve) {
            let prepared = CVE::from(&self.db, cve);
            // write cve
            let path = self.folder.to_string()
                + "/cves/"
                + &prepared.id.split("-").nth(1).unwrap()
                + "/"
                + &prepared.id
                + ".json";
            let writer = File::options()
                .write(true)
                .open(path)
                .expect("failed to open file");
            serde_json::to_writer_pretty(writer, &prepared).expect("failed to serialyze");
        }
        Ok(())
    }

    fn set_cve_last_update(&self, date: Date) {
        let f = File::open(self.folder.to_string() + "/" + "cves.json").unwrap();
        serde_json::to_writer_pretty(f, &LastUdpateInfos::new(date))
            .expect("failed to write db update");
    }

    fn get_cve_last_update(&self) -> Option<Date> {
        let c = File::open(self.folder.to_string() + "/" + "cves.json").unwrap();
        let parsed: LastUdpateInfos = serde_json::from_reader(c).expect("failed to parse");
        return Date::from_timestamp_millis(parsed.date);
    }

    pub fn update_cves(&self) {
        let last_update = self.get_cve_last_update();
        let min = Utc.with_ymd_and_hms(1970, 1, 1, 0, 0, 0).unwrap();
        let d = last_update.unwrap_or_else(|| min);
        let windows = get_windows_until_now(d);
        for w in windows {
            self.do_cve_window(&w).expect("failed to do window");
            self.set_cve_last_update(w.start);
            println!("did {:?}", w);
        }
        // get last date
        // for each windows
        // do window
        // update last update
        todo!();
    }
}
