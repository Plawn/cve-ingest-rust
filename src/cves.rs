use std::{
    fs::{self, File},
    io::{BufRead, BufReader, Write},
    ops::Sub,
};

use crate::{
    prepare_date,
    windowed::{UrlProvider, Windower},
    CveDb, Date, Vulnerability, CVE,
};
use chrono::{DateTime, Duration, TimeZone, Utc};
use serde::{Deserialize, Serialize};

#[derive(Debug)]
pub struct Window {
    pub start: Date,
    pub end: Date,
}

/// split date interval
pub fn get_windows_until_now(s: DateTime<Utc>, window_size: Duration) -> Vec<Window> {
    let mut start = Utc::now();

    if start.sub(window_size) <= s {
        return vec![Window {
            end: start,
            start: s,
        }];
    }

    // si le dernier est moins que window size,
    // alors prendre juste la diff
    let mut res = vec![];
    while start > s {
        let end = start.sub(window_size); // today minus 30 days
        let w = Window {
            start: end,
            end: start,
        };
        res.push(w);
        start = end;
    }
    res.reverse();
    res
}

#[derive(Deserialize, Debug, Serialize)]
pub struct LastUdpateInfos {
    /// encoded as timestamp
    pub date: i64,
}

impl LastUdpateInfos {
    pub fn new(d: &Date) -> Self {
        Self {
            date: d.timestamp_millis(),
        }
    }
}

impl UrlProvider for Vulnerability {
    fn url(start: Date, end: Date, index: u32) -> String {
        let url = format!(
            "https://services.nvd.nist.gov/rest/json/cves/2.0/?lastModStartDate={}&lastModEndDate={}&startIndex={}", prepare_date(&start), prepare_date(&end), index);
        url
    }
}

fn write_pretty_json_to_file<T: Serialize>(path: &str, value: &T, flush: Option<bool>) {
    let mut writer: File = File::options()
        .create(true)
        .write(true)
        .open(path)
        .expect("failed to open file");
    serde_json::to_writer_pretty(&writer, &value).expect("failed to serialyze");
    if flush.unwrap_or(false) {
        writer.flush().expect("failed to flush file");
    }
}

impl CveDb {
    fn do_cve_window(&self, w: &Window) -> Result<(), Box<dyn std::error::Error>> {
        let size_hint = Some(2000);
        let w = Windower::<'_, _, Vulnerability>::new(
            w.start,
            w.end,
            &"vulnerabilities".as_bytes(),
            size_hint,
        )
        .filter_map(|e| match e {
            Err(err) => {
                eprintln!("Failed to parse: {:?}", &err);
                return None;
            }
            Ok(v) => Some(v),
        });
        for cve in w.map(|e: Vulnerability| e.cve) {
            let prepared = CVE::from(&self.db, cve);
            let path = prepared.local_path(&self.folder);
            println!("writing to path: {}", path);
            write_pretty_json_to_file(&path, &prepared, None);
        }
        Ok(())
    }

    fn update_infos_filepath(&self) -> String {
        format!("{}/cves.json", self.folder.to_string())
    }

    fn set_cve_last_update(&self, date: &Date) {
        write_pretty_json_to_file(
            &self.update_infos_filepath(),
            &LastUdpateInfos::new(date),
            Some(true),
        )
    }

    fn get_cve_last_update(&self) -> Option<Date> {
        let c = File::open(self.update_infos_filepath()).ok();
        if let Some(file) = c {
            let parsed: LastUdpateInfos = serde_json::from_reader(file).expect("failed to parse");
            return Date::from_timestamp_millis(parsed.date);
        }
        Option::None
    }

    fn ensure_dir_exists(&self) {
        // to make cleaner
        let years = 1999..2025;
        years.for_each(|y| {
            fs::create_dir_all(format!("{}/cves/{}", &self.folder, y))
                .expect("failed to create folder");
        });
    }

    /// will return the cve names
    pub fn get_cves_by_cots(&self, name: &str, version: &str) -> Option<Vec<String>> {
        let path = self.format_product_path(name, version);
        let f = File::options().read(true).open(&path);
        if let Ok(file) = f {
            let reader = BufReader::new(&file);
            let e = reader
                .lines()
                .map(|e| e.unwrap())
                .map(|e| e.split(" ").next().unwrap().to_owned())
                .collect::<Vec<_>>();
            return Some(e);
        }
        return None;
    }

    pub fn update_cves(&self) {
        self.ensure_dir_exists();
        let last_update = self.get_cve_last_update();
        let min = Utc.with_ymd_and_hms(2019, 1, 1, 0, 0, 0).unwrap();
        let d = last_update.unwrap_or(min);
        let window_size = Duration::days(20);
        let windows = get_windows_until_now(d, window_size);
        for w in windows {
            println!("doing {:?}", w);
            self.do_cve_window(&w).expect("failed to do window");
            self.set_cve_last_update(&w.start);
            println!("did {:?}", w);
        }
    }
}
