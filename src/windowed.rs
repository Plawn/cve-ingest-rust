use std::io::{BufReader, Read};

use jsonit::{JsonItError, JsonSeqIterator};
use serde::de::DeserializeOwned;

use crate::{http_client::RetryClient, Date};

#[derive(Default)]
struct State<'a, R, O> {
    index: u32,
    it: Option<JsonSeqIterator<'a, R, O>>,
    pristine: bool,
    done: u32,
}

impl<'a, R: Read, O: DeserializeOwned> State<'a, R, O> {
    fn new() -> Self {
        Self {
            index: 0,
            done: 0,
            it: None,
            pristine: true,
        }
    }

    fn next_it(
        &mut self,
        mut it: JsonSeqIterator<'a, R, O>,
        new_index: u32,
    ) -> Option<Result<O, JsonItError>> {
        let n = it.next();
        self.index = new_index;
        self.pristine = true;
        self.it = Some(it);
        n
    }
}

pub struct Windower<'a, R: Read, O: DeserializeOwned> {
    start: Option<Date>,
    end: Option<Date>,
    output_type: std::marker::PhantomData<O>,
    state: State<'a, R, O>,
    prefix: &'a [u8],
    client: RetryClient,
    size_hint: Option<u32>,
    api_key: Option<String>,
    on_response: Option<Box<dyn Fn(u32)>>,
}

impl<'a, R: Read, O: DeserializeOwned> Windower<'a, R, O> {
    pub fn new(
        start: Option<Date>,
        end: Option<Date>,
        prefix: &'a [u8],
        api_key: Option<String>,
        size_hint: Option<u32>,
        on_response: Option<Box<dyn Fn(u32)>>,
    ) -> Self {
        Self {
            prefix,
            start,
            end,
            state: State::new(),
            output_type: std::marker::PhantomData,
            client: RetryClient::default(),
            size_hint,
            api_key,
            on_response,
        }
    }
}

pub trait UrlProvider {
    fn url(start: Option<Date>, end: Option<Date>, index: u32, api_key: &Option<String>) -> String;
}

impl<'a, O: DeserializeOwned + UrlProvider>
    Windower<'a, BufReader<reqwest::blocking::Response>, O>
{
    fn get_response(&self, index: u32) -> BufReader<reqwest::blocking::Response> {
        let url = O::url(self.start, self.end, index, &self.api_key);
        let response = self.client.get_response(&url).1;
        if let Some(f) = &self.on_response {
            (f)(index);
        }
        response
    }
}

impl<'a, O: DeserializeOwned + UrlProvider>
    Windower<'a, BufReader<reqwest::blocking::Response>, O>
{
    fn next_it(&mut self, index: u32) -> Option<Result<O, JsonItError>> {
        let read = self.get_response(index);
        self.state.done = 0;
        let it = JsonSeqIterator::new(read, self.prefix);
        self.state.next_it(it, index)
    }
}

impl<'a, O: DeserializeOwned + UrlProvider> Iterator
    for Windower<'a, BufReader<reqwest::blocking::Response>, O>
{
    type Item = Result<O, JsonItError>;

    fn next(&mut self) -> Option<Self::Item> {
        match self.state.it.as_mut() {
            // missing iterator -> should start
            None => self.next_it(0),
            Some(it) => {
                match it.next() {
                    Some(e) => {
                        self.state.pristine = false;
                        self.state.done += 1;
                        Some(e)
                    }
                    None => match self.state.pristine {
                        true => None, // if the iterator is pristine -> end iter
                        // we got the last item of the iterator having values
                        false => {
                            // we need to recreate the next iterator
                            // if we are lower than hint then we can avoid sending one more request for this window
                            if let Some(window_int) = self.size_hint {
                                if self.state.done < window_int {
                                    return None;
                                }
                            }
                            let new_index = self.state.index + self.state.done;
                            self.next_it(new_index)
                        }
                    },
                }
            }
        }
    }
}
