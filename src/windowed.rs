use std::{
    io::{BufReader, Read},
    rc::Rc,
    thread::sleep,
    time::Duration,
};

use jsonit::JsonSeqIterator;
use serde::de::DeserializeOwned;

use crate::Date;

struct State<'a, R, O> {
    index: u32,
    it: Option<JsonSeqIterator<'a, R, O>>,
    next_it: Option<JsonSeqIterator<'a, R, O>>,
    pristine: bool,
    done: u32,
}

impl<'a, R: Read, O: DeserializeOwned> State<'a, R, O> {
    fn new() -> Self {
        Self {
            index: 0,
            done: 0,
            it: None,
            next_it: None,
            pristine: true,
        }
    }

    fn next_it(&mut self, mut it: JsonSeqIterator<'a, R, O>, new_index: u32) -> Option<Result<O, anyhow::Error>> {
        let n = it.next();
        self.index = self.index + new_index;
        self.pristine = true;
        self.it = Some(it);
        n
    }

}

pub struct Windower<'a, R: Read, O: DeserializeOwned> {
    pub start: Date,
    pub end: Date,
    output_type: std::marker::PhantomData<O>,
    state: State<'a, R, O>,
    prefix: &'a [u8],
}

impl<'a, R: Read, O: DeserializeOwned> Windower<'a, R, O> {
    pub fn new(start: Date, end: Date, prefix: &'a [u8]) -> Self {
        Self {
            prefix,
            start,
            end,
            state: State::new(),
            output_type: std::marker::PhantomData,
        }
    }

}

enum CurrentState<O: DeserializeOwned> {
    Uninitialized, 
    Result(Option<Result<O, anyhow::Error>>),
}

pub trait UrlProvider {
    fn url(start: Date, end: Date, index: u32) -> String;
}

impl<'a, O: DeserializeOwned + UrlProvider>
    Windower<'a, BufReader<reqwest::blocking::Response>, O>
{
    fn get_response(&self, index: u32) -> BufReader<reqwest::blocking::Response> {
        let url = O::url(self.start, self.end, index);
        println!("{}", &url);
        let res = loop {
            match reqwest::blocking::get(&url) {
                Ok(r) => {
                    if r.status() == 200 {
                        break r;
                    }
                    println!("Got error: {} -> sleeping for 5 secs", r.status());
                    sleep(Duration::from_secs(5));
                }
                Err(err) => {
                    println!("sleeping for 5 sec: {}", err);
                    sleep(Duration::from_secs(5));
                }
            }
        };
        BufReader::new(res)
    }
}

impl<'a, O: DeserializeOwned + UrlProvider> Iterator
    for Windower<'a, BufReader<reqwest::blocking::Response>, O>
{
    type Item = Result<O, anyhow::Error>;

    fn next(&mut self) -> Option<Self::Item> {
        match self.state.it.as_mut() {
            // missing iterator -> should start
            None => {
                let read = self.get_response(0);
                let id = JsonSeqIterator::new(read, self.prefix);
                self.state.it = Some(id);
                self.state.pristine = true;
                self.state.index = 0;
                self.state.done = 0;
                todo!()
            }
            Some(it) => {
                match it.next() {
                    Some(e) => {
                        self.state.pristine = false;
                        self.state.done = 0;
                        let o = e;
                        Some(o)
                    }
                    None => match self.state.pristine {
                        true => None, // if the iterator is pristine -> end iter
                        // we got the last item of the iterator having values
                        false => {
                            // we need to recreate the next iterator
                            let new_index = self.state.index + self.state.done;
                            let read: BufReader<reqwest::blocking::Response> =
                                self.get_response(new_index);
                            let it = JsonSeqIterator::new(read, self.prefix);
                            let n = self.state.next_it(it, new_index);
                            n
                        }
                    },
                }
            }
        }
    }
}
