#![cfg_attr(bootstrap, feature(generators))]
#![cfg_attr(not(bootstrap), feature(coroutines))]
#![feature(coroutine_trait)]

use std::error::Error;
use std::io::BufReader;
use std::iter::Map;
use std::{collections::HashMap, ops::CoroutineState};

use chrono::{Duration, Utc};

use cve_ingest_rust::{prepare_date, Date, Root};
use serde_json::Value;

struct Window {
    start: Date,
    end: Date,
}

fn get_url(window: &Window, start_index: u32) -> String {
    // let url = "https://services.nvd.nist.gov/rest/json/cves/2.0/?lastModStartDate=2023-10-29T13:32:53.000%2B01:00&lastModEndDate=2023-10-29T21:32:53.000%2B01:00&startIndex=0";
    let url = format!(
        "https://services.nvd.nist.gov/rest/json/cves/2.0/?lastModStartDate={}&lastModEndDate={}&startIndex={}", prepare_date(&window.start), prepare_date(&window.end), start_index);
    return url;
}

struct Cpe {}

async fn get_cpes() -> HashMap<String, Cpe> {
    // fetch cpes into map or maybe rocksdb
    let map = HashMap::new();

    return map;
}

async fn do_window(w: &Window) -> Result<(), Box<dyn std::error::Error>> {
    let url = get_url(&w, 0);
    println!("{}", &url);
    let resp = reqwest::get(url).await?.json::<Root>().await?;
    println!("{:#?}", resp);
    Ok(())
}

// split date interval
fn get_windows() -> Vec<Window> {
    let mut res = vec![];
    let mut start = Utc::now();
    let end = Utc::now();
    start = start.checked_sub_signed(Duration::hours(8)).unwrap();
    let w = Window { start, end };
    res.push(w);
    return res;
}

// #[tokio::main]
// async fn main() -> Result<(), Box<dyn std::error::Error>> {
//     let cpes = get_cpes().await;
//     let windows = get_windows();
//     for w in windows {
//         do_window(&w).await?;
//     }
//     Ok(())
// }

// use std::ops::{Generator, GeneratorState};
use std::pin::Pin;

// use ijson::parser::Parser;
use std::fs::File;
use std::ops::Coroutine;
// fn main() {
//     let mut coroutine = || {
//         yield 12;
//         "foo"
//     };

//     match Pin::new(&mut coroutine).resume(()) {
//         CoroutineState::Yielded(value) => {
//             println!("got value: {}", value);
//         }
//         _ => panic!("unexpected return from resume"),
//     }
//     match Pin::new(&mut coroutine).resume(()) {
//         CoroutineState::Complete("foo") => {}
//         _ => panic!("unexpected return from resume"),
//     }
// }
use core::slice::Iter;

#[derive(PartialEq)]
enum ParseValueType {
    String,
    Number,
    Null,
    Undefined,
    Unknown,
}

#[derive(PartialEq)]
enum State {
    ParseObjectKey,
    ParseObject,
    ParseValue(ParseValueType),
    ExpectValue,
    /// We expect ":" or whitespace
    ExpectPoints,
    None,
    // / for \" items
    // Escape,
}

#[derive(PartialEq, Debug)]
enum Delimiter {
    Item(String),
    End,
    Skip,
    Start,
}

/// will only support the stream loading of an array of object under a object key chain, like "a.b.c"
/// c containing the objects of type T
pub fn stream_read_array_at(
    iterator: impl Iterator<Item = String> + 'static,
    prefix: String,
) -> impl Iterator<Item = Delimiter> + 'static {
    let mut current_key = String::new();

    let mut in_key = false;
    let mut object_nesting = 0;
    let mut state = State::None;
    // only handle when inside the returned value
    let mut array_nesting = 0;

    let mut escape = false;

    let mut parse_is_done = false;
    return iterator.map(move |s| {
        let c = s;
        println!("char: {} | key {} | len {}", c, &current_key, c.len());

        // return the rest as we are done with the iterator
        if parse_is_done {
            return Delimiter::Skip;
        }
        // if we are in the searched key
        if current_key == prefix {
            // end of parsing, skip the rest of the stream
            if c == "]" && array_nesting == 0 {
                parse_is_done = true;
                return Delimiter::Skip;
            } else {
                if c == "}" && object_nesting == 0 {
                    return Delimiter::End;
                }
                if c == "{" && object_nesting == 0 {
                    return Delimiter::Start;
                }
                return Delimiter::Item(c);
            }
        }

        // if escape char
        if c == "\\" {
            escape = true;
            return Delimiter::Skip;
        }

        // here we search the key
        // should never return item, from this point on

        match &state {
            // handle current key count
            State::ParseObjectKey => {
                if c == "\"" && !escape {
                    state = State::ExpectPoints;
                } else {
                    current_key.push_str(c.as_str());
                }
                return Delimiter::Skip;
            }
            State::ParseValue(t) => {
                // detect end of value
                match t {
                    ParseValueType::String => {
                        if c == "\"" && !escape {
                            state = State::ParseObject;
                        }
                        if escape {
                            escape = false;
                        }
                    }
                    ParseValueType::Number => {
                        if c == "," {
                            state = State::ParseObject;
                        }
                    }
                    ParseValueType::Null => {
                        if c == "," {
                            state = State::ParseObject;
                        }
                    }
                    ParseValueType::Undefined => {
                        if c == "," {
                            state = State::ParseObject;
                        }
                    }
                    // needed ?
                    ParseValueType::Unknown => {}
                };
            }
            State::ExpectValue => {
                if c == "\"" {
                    state = State::ParseValue(ParseValueType::String);
                } else if c == "n" {
                    state = State::ParseValue(ParseValueType::Null);
                } else if c == "u" {
                    state = State::ParseValue(ParseValueType::Undefined);
                } else {
                    state = State::ParseValue(ParseValueType::Number);
                }
            }
            State::ExpectPoints => {
                if c == ":" {
                    state = State::ExpectValue;
                }
            }
            State::ParseObject => {
                if c == "\"" {
                    state = State::ParseObjectKey;
                }
            }
            State::None => {
                if c == "{" {
                    // start root of object
                    state = State::ParseObject;
                } else if c == "[" {
                    panic!("arrays are unsupported for now");
                } else if c != " " {
                    panic!("malformed");
                }
            }
        };
        return Delimiter::Skip;
    });
    // here fold by start and end
    // parse result folded string
    // return stream of parsed struct
}

use std::io::BufRead;

fn main() -> Result<(), Box<dyn Error>> {
    let prefix = "root.items";
    let f = File::open("t.json")?;
    let reader = BufReader::new(f);
    // let reader = buffered(f, 10);
    let i = reader
        .lines()
        .into_iter()
        .map(|l| l.unwrap().chars().map(|e| e.to_string()).collect::<Vec<_>>()).flatten();
    let r = stream_read_array_at(i, String::from(prefix));
    println!("{:?}", r.collect::<Vec<_>>());
    Ok(())
}
