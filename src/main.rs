use bytevec::{ByteDecodable, ByteEncodable};
use chrono::{Duration, Utc};
use cve_ingest_rust::{prepare_date, Date, Root};
use flate2::read::GzDecoder;
use ijson::IString;
use itertools::Itertools;
use jsonit::make_path;
use jsonit::JsonSeqIterator;
use rocksdb::WriteBatchWithTransaction;
use rocksdb::DB;
use serde::Deserialize;
use std::error::Error;

struct Window {
    start: Date,
    end: Date,
}

fn get_url(window: &Window, start_index: u32) -> String {
    // let url = "https://services.nvd.nist.gov/rest/json/cves/2.0/?lastModStartDate=2023-10-29T13:32:53.000%2B01:00&lastModEndDate=2023-10-29T21:32:53.000%2B01:00&startIndex=0";
    let url = format!(
        "https://services.nvd.nist.gov/rest/json/cves/2.0/?lastModStartDate={}&lastModEndDate={}&startIndex={}", prepare_date(&window.start), prepare_date(&window.end), start_index);
    url
}

struct Cpe {}

async fn do_window(w: &Window) -> Result<(), Box<dyn std::error::Error>> {
    let url = get_url(w, 0);
    println!("{}", &url);
    let resp = reqwest::get(url).await?.json::<Root>().await?;
    println!("{:#?}", resp);
    Ok(())
}

// split date interval
fn get_windows() -> Vec<Window> {
    let mut res = vec![];
    let mut start = Utc::now();
    let end = Utc::now();
    start = start.checked_sub_signed(Duration::hours(8)).unwrap();
    let w = Window { start, end };
    res.push(w);
    res
}

#[derive(Deserialize, Debug, serde::Serialize)]
struct CpeName {
    #[serde(rename = "cpe23Uri")]
    cpe_23_uri: String,
}

#[derive(Deserialize, Debug, serde::Serialize)]
struct CPE {
    #[serde(rename = "cpe23Uri")]
    cpe_23_uri: IString,
    cpe_name: Vec<CpeName>,
    #[serde(rename = "versionStartExcluding")]
    version_start_excluding: Option<IString>,
    #[serde(rename = "versionStartIncluding")]
    version_start_including: Option<IString>,
    #[serde(rename = "versionEndExcluding")]
    version_end_excluding: Option<IString>,
    #[serde(rename = "versionEndIncluding")]
    version_end_including: Option<IString>,
}

fn get_db() -> Result<DB, rocksdb::Error> {
    let path = "_db";
    let db = DB::open_default(path)?;
    Ok(db)
}

fn prepare_query(cpe: &CPE) -> Box<str> {
    // deno-lint-ignore no-explicit-any
    let mut version_info = String::new();
    if let Some(v) = &cpe.version_start_excluding {
        version_info.push_str(v.as_str());
        version_info.push_str("_VSE");
    }

    if let Some(v) = &cpe.version_start_including {
        version_info.push_str(v.as_str());
        version_info.push_str("_VSI");
    }

    if let Some(v) = &cpe.version_end_excluding {
        version_info.push_str(v.as_str());
        version_info.push_str("_VEE");
    }
    if let Some(v) = &cpe.version_end_including {
        version_info.push_str(v.as_str());
        version_info.push_str("_VEI");
    }

    version_info.into()
}

fn make_index(cpe: &CPE) -> [u8; 20] {
    use sha1::{Sha1, Digest};
    let version_info = prepare_query(cpe);
    let mut hasher = Sha1::new();
    hasher.update(cpe.cpe_23_uri.as_bytes());
    hasher.update(version_info.as_bytes());
    return hasher.finalize().into();
}

fn update_cpes() -> Result<(), Box<dyn Error>> {
    let db = get_db()?;
    let chunk_size = 5000;

    const CPE_URL: &str = "https://nvd.nist.gov/feeds/json/cpematch/1.0/nvdcpematch-1.0.json.gz";
    let prepared_prefix = make_path("matches");

    let response = reqwest::blocking::get(CPE_URL).unwrap();
    let gz_decoder = GzDecoder::new(response);
    let json_iterator =
        JsonSeqIterator::<'_, _, CPE>::new(gz_decoder, &prepared_prefix).map(|e| e.unwrap());

    let _ = &json_iterator
        .chunks(chunk_size)
        .into_iter()
        .map(|chunk| {
            chunk.map(|item| {
                let encoded = item
                    .cpe_name
                    .iter()
                    .map(|e| e.cpe_23_uri.as_str())
                    .collect::<Box<_>>()
                    .encode::<u32>()
                    .unwrap();
                // used to check with current implem
                // if (item.cpe_23_uri.as_str() == "cpe:2.3:a:\\@thi.ng\\/egf_project:\\@thi.ng\\/egf:*:*:*:*:*:node.js:*:*") {
                //     println!("got index: {:x?}", make_index(&item));
                // }
                (make_index(&item), encoded)
            })
        })
        .enumerate()
        .for_each(|(i, c)| {
            let mut batch = WriteBatchWithTransaction::<false>::default();
            c.for_each(|e| {
                let _ = &batch.put(e.0, &e.1);
                // println!("{:?}", e.1);
            });
            let _ = db.write(batch);
            println!("handle batch: {}", i * chunk_size);
        });

    Ok(())
}

fn main() -> Result<(), Box<dyn Error>> {
    update_cpes()?;
    Ok(())
}
