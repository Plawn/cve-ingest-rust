use bytevec::{ByteDecodable, ByteEncodable};
use chrono::{Duration, Utc};
use cve_ingest_rust::CPE;
use cve_ingest_rust::{prepare_date, Date, Root};
use flate2::read::GzDecoder;
use itertools::Itertools;
use jsonit::make_path;
use jsonit::JsonSeqIterator;
use rocksdb::WriteBatchWithTransaction;
use rocksdb::DB;
use std::error::Error;
use std::io::BufReader;
use hex_literal::hex;
struct Window {
    start: Date,
    end: Date,
}

fn get_url(window: &Window, start_index: u32) -> String {
    // let url = "https://services.nvd.nist.gov/rest/json/cves/2.0/?lastModStartDate=2023-10-29T13:32:53.000%2B01:00&lastModEndDate=2023-10-29T21:32:53.000%2B01:00&startIndex=0";
    let url = format!(
        "https://services.nvd.nist.gov/rest/json/cves/2.0/?lastModStartDate={}&lastModEndDate={}&startIndex={}", prepare_date(&window.start), prepare_date(&window.end), start_index);
    url
}


async fn do_window(w: &Window) -> Result<(), Box<dyn std::error::Error>> {
    let url = get_url(w, 0);
    println!("{}", &url);
    let resp = reqwest::get(url).await?.json::<Root>().await?;
    println!("{:#?}", resp);
    Ok(())
}

// split date interval
fn get_windows() -> Vec<Window> {
    let mut res = vec![];
    let mut start = Utc::now();
    let end = Utc::now();
    start = start.checked_sub_signed(Duration::hours(8)).unwrap();
    let w = Window { start, end };
    res.push(w);
    res
}

fn get_db() -> Result<DB, rocksdb::Error> {
    let path = "_db";
    let db = DB::open_default(path)?;
    Ok(db)
}

fn prepare_query(cpe: &CPE) -> Box<str> {
    // deno-lint-ignore no-explicit-any
    let mut version_info = String::new();
    if let Some(v) = &cpe.version_start_excluding {
        version_info.push_str(v.as_str());
        version_info.push_str("_VSE");
    }

    if let Some(v) = &cpe.version_start_including {
        version_info.push_str(v.as_str());
        version_info.push_str("_VSI");
    }

    if let Some(v) = &cpe.version_end_excluding {
        version_info.push_str(v.as_str());
        version_info.push_str("_VEE");
    }
    if let Some(v) = &cpe.version_end_including {
        version_info.push_str(v.as_str());
        version_info.push_str("_VEI");
    }

    version_info.into()
}

fn make_index(cpe: &CPE) -> [u8; 20] {
    use sha1::{Sha1, Digest};
    let version_info = prepare_query(cpe);
    let mut hasher = Sha1::new();
    hasher.update(cpe.cpe_23_uri.as_bytes());
    hasher.update(version_info.as_bytes());
    return hasher.finalize().into();
}

fn update_cpes(chunk_size: usize) -> Result<(), Box<dyn Error>> {
    let db = get_db()?;

    const CPE_URL: &str = "https://nvd.nist.gov/feeds/json/cpematch/1.0/nvdcpematch-1.0.json.gz";
    let prepared_prefix = make_path("matches");

    let response = reqwest::blocking::get(CPE_URL).unwrap();
    let buf = BufReader::new(response);
    let gz_decoder = GzDecoder::new(buf);
    let json_iterator =
        JsonSeqIterator::<'_, _, CPE>::new(gz_decoder, &prepared_prefix).map(|e| e.expect("Failed to parse json"));

    let _ = &json_iterator
        .chunks(chunk_size)
        .into_iter()
        .map(|chunk| {
            chunk.map(|item| {
                let encoded = item
                    .cpe_name
                    .iter()
                    .map(|e| e.cpe_23_uri.as_str())
                    .collect::<Box<_>>()
                    .encode::<u32>()
                    .expect("Failed to encode string to binary");
                (make_index(&item), encoded)
            })
        })
        .enumerate()
        .for_each(|(i, c)| {
            let mut batch = WriteBatchWithTransaction::<false>::default();
            c.for_each(|e| {
                let _ = &batch.put(e.0, &e.1);
            });
            let _ = db.write(batch);
            println!("handle batch: {}", i * chunk_size);
        });

    Ok(())
}

fn get_cpes(db: &DB, key: [u8;20]) -> Vec<String> {
    let res = db.get(key).unwrap().unwrap(); // read bytes from db
    let decoded = <Vec<String>>::decode::<u32>(&res).unwrap(); // decode from bytes encoding
    decoded
}

fn main() -> Result<(), Box<dyn Error>> {
    let chunk_size = 1000;
    update_cpes(chunk_size)?;
    // let db = get_db()?;
    // let values = get_cpes(&db, hex!("8c75e4c943018b62babc49403bcc3aad6274884f"));
    // println!("{:?}", values);
    Ok(())
}
