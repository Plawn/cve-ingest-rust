use bytevec::{ByteDecodable, ByteEncodable};
use chrono::{Duration, Utc};
use cve_ingest_rust::{prepare_date, CveDb, Date, Root};
use cve_ingest_rust::{NVDCve, CPE, CVE};
use flate2::read::GzDecoder;
use itertools::Itertools;
use jsonit::make_path;
use jsonit::JsonSeqIterator;
use rocksdb::WriteBatchWithTransaction;
use rocksdb::DB;
use std::error::Error;
use std::io::BufReader;
use std::rc::Rc;
struct Window {
    start: Date,
    end: Date,
}

fn get_url(window: &Window, start_index: u32) -> String {
    // let url = "https://services.nvd.nist.gov/rest/json/cves/2.0/?lastModStartDate=2023-10-29T13:32:53.000%2B01:00&lastModEndDate=2023-10-29T21:32:53.000%2B01:00&startIndex=0";
    let url = format!(
        "https://services.nvd.nist.gov/rest/json/cves/2.0/?lastModStartDate={}&lastModEndDate={}&startIndex={}", prepare_date(&window.start), prepare_date(&window.end), start_index);
    url
}

async fn do_window(w: &Window) -> Result<(), Box<dyn std::error::Error>> {
    let url = get_url(w, 0);
    println!("{}", &url);
    let resp = reqwest::get(url).await?.json::<Root>().await?;
    // finalyze implem here
    // try to get chunked with iter on vulnerabilities field
    // use blocking
    println!("{:#?}", resp);
    Ok(())
}

// split date interval
fn get_windows() -> Vec<Window> {
    let mut res = vec![];
    let mut start = Utc::now();
    let end = Utc::now();
    start = start.checked_sub_signed(Duration::hours(8)).unwrap();
    let w = Window { start, end };
    res.push(w);
    res
}

fn get_db() -> Result<DB, rocksdb::Error> {
    let path = "_db";
    let db = DB::open_default(path)?;
    Ok(db)
}

fn prepare_query(cpe: &CPE) -> Box<str> {
    let mut version_info = String::new();
    if let Some(v) = &cpe.version_start_excluding {
        version_info.push_str(v.as_str());
        version_info.push_str("_VSE"); // in order to have the same index as the original lib
    }

    if let Some(v) = &cpe.version_start_including {
        version_info.push_str(v.as_str());
        version_info.push_str("_VSI"); // in order to have the same index as the original lib
    }

    if let Some(v) = &cpe.version_end_excluding {
        version_info.push_str(v.as_str());
        version_info.push_str("_VEE"); // in order to have the same index as the original lib
    }
    if let Some(v) = &cpe.version_end_including {
        version_info.push_str(v.as_str());
        version_info.push_str("_VEI"); // in order to have the same index as the original lib
    }

    version_info.into()
}

fn make_index(cpe: &CPE) -> [u8; 20] {
    use sha1::{Digest, Sha1};
    let version_info = prepare_query(cpe);
    let mut hasher = Sha1::new();
    hasher.update(cpe.cpe_23_uri.as_bytes());
    hasher.update(version_info.as_bytes());
    return hasher.finalize().into();
}
/// Update the CPES in the rockDB database
///
/// Uses the index to store the cpe list as binary
///
/// Panics on json error or db error
fn update_cpes(db: &DB, chunk_size: usize) -> Result<(), Box<dyn Error>> {
    const CPE_URL: &str = "https://nvd.nist.gov/feeds/json/cpematch/1.0/nvdcpematch-1.0.json.gz";
    let prepared_prefix = make_path("matches");

    let response =
        reqwest::blocking::get(CPE_URL).expect("Failed to get CPE data, network call failed");
    let buf = BufReader::new(response);
    let gz_decoder = GzDecoder::new(buf);
    let json_iterator = JsonSeqIterator::new(gz_decoder, &prepared_prefix)
        .map(|e| e.expect("Failed to parse json"));

    let _ = &json_iterator
        .chunks(chunk_size)
        .into_iter()
        .map(|chunk| {
            chunk.map(|item: CPE| {
                let encoded = item
                    .cpe_name
                    .iter()
                    .map(|e| e.cpe_23_uri.as_str())
                    .collect::<Rc<_>>()
                    .encode::<u32>() // use u32 as utf-8 can be up to 4bytes
                    .expect("Failed to encode string to binary");
                (make_index(&item), encoded)
            })
        })
        .enumerate()
        .for_each(|(i, c)| {
            let mut batch = WriteBatchWithTransaction::<false>::default();
            c.for_each(|e| {
                let _ = &batch.put(e.0, &e.1);
            });
            let _ = db.write(batch);
            println!("handle batch: {}", i * chunk_size);
        });

    Ok(())
}

fn get_cpes_for_index(db: &DB, index: [u8; 20]) -> Option<Vec<String>> {
    let res = db.get_pinned(index).expect("Failed to open database"); // read bytes from db
    if let Some(r) = res {
        let decoded = <Vec<String>>::decode::<u32>(&r).unwrap(); // decode from bytes encoding
        return Option::Some(decoded);
    }
    Option::None
}

fn main() -> Result<(), Box<dyn Error>> {
    // let chunk_size = 1000;
    // let db = get_db()?;
    // update_cpes(&db, chunk_size)?;
    // for each cve window get and map
    let d = CveDb::from("cves");
    d.bind();
    Ok(())
}
