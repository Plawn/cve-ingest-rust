// use std::fs::File;

use flate2::read::GzDecoder;
// use async_compression::futures::bufread::GzipDecoder;
use ::futures::TryStreamExt;
use async_compression::tokio::bufread::GzipDecoder;
// use ::futures::stream::TryStreamExt;
use tokio::io::AsyncBufReadExt;
use tokio_util::compat::FuturesAsyncReadCompatExt;
// use futures_util::stream::ErrInto;
// use futures_util::TryStreamExt;
use std::collections::HashMap;
use std::error::Error;
use std::io::BufRead;
use std::io::BufReader;
use std::iter::Map;
use std::thread;
// use tokio::io::AsyncBufReadExt;
// // use tokio::io::AsyncReadExt;
// use tokio_util::compat::FuturesAsyncReadCompatExt;
use tokio_util::io::StreamReader;

use chrono::{Duration, Utc};

use cve_ingest_rust::{prepare_date, Date, Root};
use jsonit::make_path;
use jsonit::JsonSeqIterator;
use serde::Deserialize;
use serde_json::Value;
use tokio::task::futures;

struct Window {
    start: Date,
    end: Date,
}

fn get_url(window: &Window, start_index: u32) -> String {
    // let url = "https://services.nvd.nist.gov/rest/json/cves/2.0/?lastModStartDate=2023-10-29T13:32:53.000%2B01:00&lastModEndDate=2023-10-29T21:32:53.000%2B01:00&startIndex=0";
    let url = format!(
        "https://services.nvd.nist.gov/rest/json/cves/2.0/?lastModStartDate={}&lastModEndDate={}&startIndex={}", prepare_date(&window.start), prepare_date(&window.end), start_index);
    return url;
}

struct Cpe {}

async fn get_cpes() -> HashMap<String, Cpe> {
    // fetch cpes into map or maybe rocksdb
    let map = HashMap::new();

    return map;
}

async fn do_window(w: &Window) -> Result<(), Box<dyn std::error::Error>> {
    let url = get_url(&w, 0);
    println!("{}", &url);
    let resp = reqwest::get(url).await?.json::<Root>().await?;
    println!("{:#?}", resp);
    Ok(())
}

// split date interval
fn get_windows() -> Vec<Window> {
    let mut res = vec![];
    let mut start = Utc::now();
    let end = Utc::now();
    start = start.checked_sub_signed(Duration::hours(8)).unwrap();
    let w = Window { start, end };
    res.push(w);
    return res;
}

// #[tokio::main]
// async fn main() -> Result<(), Box<dyn std::error::Error>> {
//     let cpes = get_cpes().await;
//     let windows = get_windows();
//     for w in windows {
//         do_window(&w).await?;
//     }
//     Ok(())
// }

#[derive(Deserialize, Debug)]
struct V {
    name: String,
}

const CPE_URL: &str = "https://nvd.nist.gov/feeds/json/cpematch/1.0/nvdcpematch-1.0.json.gz";

// #[tokio::main]
 fn main() -> Result<(), Box<dyn Error>> {
    let prefix = "matches";
    let prepared_prefix = make_path(prefix);
    // let reader = "".as_bytes();

    // let url = "https://f001.backblazeb2.com/file/korteur/hello-world.txt.gz";
    // let response = reqwest::get(url).await?;
    // let stream = response
    //     .bytes_stream()
    //     .map_err(|e| ::futures::io::Error::new(::futures::io::ErrorKind::Other, e))
    //     .into_async_read()
    //     .compat();
    // let gzip_decoder = GzipDecoder::new(stream);

    // // Print decompressed txt content
    // let buf_reader = tokio::io::BufReader::new(gzip_decoder);

    let mut response2 = reqwest::blocking::get(CPE_URL)?;
    let ( read, mut write) = pipe::pipe();

    thread::spawn(move || {
        let stream2 = response2
        .copy_to(&mut write);
    });
    let d = GzDecoder::new(read);
    // let r = jsonit::ReaderIter::new(buf_reader.lines());
    let it = JsonSeqIterator::<'_, _, HashMap<String, Value>>::new(d, &prepared_prefix);
    for item in it.take(1) {
        let i = item?;
        println!("{:?}", i);
    }
    Ok(())
}
