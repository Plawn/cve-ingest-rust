use std::{io::BufReader, rc::Rc};
use flate2::read::GzDecoder;
use ijson::IString;
use serde::Deserialize;
use std::error::Error;
use itertools::Itertools;
use jsonit::{make_path, JsonSeqIterator};
use rocksdb::{WriteBatchWithTransaction, DB};

use crate::db::CveDb;
use bytevec::{ByteDecodable, ByteEncodable};
    
#[derive(Deserialize, Debug, serde::Serialize)]
pub struct CpeName {
    #[serde(rename = "cpe23Uri")]
    pub cpe_23_uri: String,
}

#[derive(Deserialize, Debug, serde::Serialize)]
pub struct CPE {
    #[serde(rename = "cpe23Uri")]
    pub cpe_23_uri: IString,
    pub cpe_name: Vec<CpeName>,
    #[serde(rename = "versionStartExcluding")]
    pub version_start_excluding: Option<IString>,
    #[serde(rename = "versionStartIncluding")]
    pub version_start_including: Option<IString>,
    #[serde(rename = "versionEndExcluding")]
    pub version_end_excluding: Option<IString>,
    #[serde(rename = "versionEndIncluding")]
    pub version_end_including: Option<IString>,
}


fn make_index(cpe: &CPE) -> [u8; 20] {
    use sha1::{Digest, Sha1};
    let version_info = prepare_query(cpe);
    let mut hasher = Sha1::new();
    hasher.update(cpe.cpe_23_uri.as_bytes());
    hasher.update(version_info.as_bytes());
    return hasher.finalize().into();
}

fn prepare_query(cpe: &CPE) -> Box<str> {
    let mut version_info = String::new();
    if let Some(v) = &cpe.version_start_excluding {
        version_info.push_str(v.as_str());
        version_info.push_str("_VSE"); // in order to have the same index as the original lib
    }

    if let Some(v) = &cpe.version_start_including {
        version_info.push_str(v.as_str());
        version_info.push_str("_VSI"); // in order to have the same index as the original lib
    }

    if let Some(v) = &cpe.version_end_excluding {
        version_info.push_str(v.as_str());
        version_info.push_str("_VEE"); // in order to have the same index as the original lib
    }
    if let Some(v) = &cpe.version_end_including {
        version_info.push_str(v.as_str());
        version_info.push_str("_VEI"); // in order to have the same index as the original lib
    }

    version_info.into()
}

impl CveDb {

    /// Update the CPES in the rockDB database
    ///
    /// Uses the index to store the cpe list as binary
    ///
    /// Panics on json error or db error
    pub fn update_cpes(&self, chunk_size: usize) -> Result<(), Box<dyn Error>> {
        const CPE_URL: &str = "https://nvd.nist.gov/feeds/json/cpematch/1.0/nvdcpematch-1.0.json.gz";
        let prepared_prefix = make_path("matches");
        let db = self.db.clone();
        let response =
            reqwest::blocking::get(CPE_URL).expect("Failed to get CPE data, network call failed");
        let buf = BufReader::new(response);
        let gz_decoder = GzDecoder::new(buf);
        let json_iterator = JsonSeqIterator::new(gz_decoder, &prepared_prefix)
            .map(|e| e.expect("Failed to parse json"));
    
        let _ = &json_iterator
            .chunks(chunk_size)
            .into_iter()
            .map(|chunk| {
                chunk.map(|item: CPE| {
                    let encoded = item
                        .cpe_name
                        .iter()
                        .map(|e| e.cpe_23_uri.as_str())
                        .collect::<Rc<_>>()
                        .encode::<u32>() // use u32 as utf-8 can be up to 4bytes
                        .expect("Failed to encode string to binary");
                    (make_index(&item), encoded)
                })
            })
            .enumerate()
            .for_each(|(i, c)| {
                let mut batch = WriteBatchWithTransaction::<false>::default();
                c.for_each(|e| {
                    let _ = &batch.put(e.0, &e.1);
                });
                let _ = db.write(batch);
                println!("handle batch: {}", i * chunk_size);
            });
    
        Ok(())
    }
    

    
}

pub fn get_cpes_for_index(db: &DB, index: &str) -> Option<Vec<String>> {
    let res = db.get_pinned(index).expect("Failed to open database"); // read bytes from db
    if let Some(r) = res {
        let decoded = <Vec<String>>::decode::<u32>(&r).unwrap(); // decode from bytes encoding
        return Option::Some(decoded);
    }
    Option::None
}