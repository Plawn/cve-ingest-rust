use std::fs::File;

use std::io::Write;
use std::rc::Rc;
use std::sync::atomic::AtomicU32;
use std::sync::Arc;

use chrono::Duration;
use chrono::TimeZone;
use chrono::Utc;

use rocksdb::WriteBatchWithTransaction;
use serde::Deserialize;
use serde::Serialize;

use crate::cves::get_windows_until_now;
use crate::cves::LastUdpateInfos;
use crate::cves::Window;
use crate::prepare_date;
use crate::windowed::UrlProvider;
use crate::windowed::Windower;

use crate::CveDb;
use crate::Date;
use bytevec::ByteEncodable;

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Root {
    pub results_per_page: i64,
    pub start_index: i64,
    pub total_results: i64,
    pub format: String,
    pub version: String,
    pub timestamp: String,
    pub match_strings: Vec<MatchString>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct MatchString {
    pub match_string: MatchString2,
}

pub fn option_to_str<T: std::fmt::Display>(name: &str, i: Option<T>) -> String {
    match i {
        Some(e) => format!("&{}={}", name, e),
        None => "".into(),
    }
}

impl UrlProvider for MatchString {
    fn url(
        start: Option<Date>,
        end: Option<Date>,
        index: u32,
        _api_key: &Option<String>,
    ) -> String {
        let url = format!(
            "https://services.nvd.nist.gov/rest/json/cpematch/2.0?startIndex={}{}{}", 
            index, option_to_str("lastModStartDate", start.map(|e| prepare_date(&e))), option_to_str("lastModEndDate", end.map(|e| prepare_date(&e))));
        url
    }
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct MatchString2 {
    /// Index to use
    pub match_criteria_id: String,
    pub criteria: String,
    pub version_end_including: Option<String>,
    pub last_modified: String,
    pub cpe_last_modified: String,
    pub created: String,
    pub status: String,
    #[serde(default)]
    pub matches: Vec<Match>,
    pub version_end_excluding: Option<String>,
    pub version_start_including: Option<String>,
    pub version_start_excluding: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Match {
    pub cpe_name: String,
    pub cpe_name_id: String,
}

#[derive(Debug)]
pub enum ScrollMode {
    Page,
    Date,
}

impl CveDb {
    fn do_pages(&self, start_page: u32) -> impl Iterator<Item = u32> {
        let size_hint = Some(500);
        let w = Windower::<'_, _, MatchString>::new(
            None,
            None,
            "matchStrings".as_bytes(),
            None, // TODO: add api_key support
            size_hint,
            None,
        )
        .filter_map(|e| {
            let r = e.ok();
            if r.is_none() {
                eprintln!("Failed to parse: {:?}", &r);
            }
            r
        })
        .map(|e| e.match_string);
        let mut count = 0;
        let mut batch = WriteBatchWithTransaction::<false>::default();
        w.map(move |item| {
            let id = item.match_criteria_id;
            let i = item
                .matches
                .iter()
                .map(|e| e.cpe_name.as_str())
                .collect::<Rc<_>>()
                .encode::<u32>()
                .expect("failed to encode");
            count += 1;
            batch.put(id.as_bytes(), i);
            count
        })
    }

    fn do_window(&self, window: &Window) -> Result<u32, Box<dyn std::error::Error>> {
        let size_hint = Some(500);
        let w = Windower::<'_, _, MatchString>::new(
            Some(window.start),
            Some(window.end),
            "matchStrings".as_bytes(),
            None, // TODO: add api_key support
            size_hint,
            None,
        )
        .filter_map(|e| {
            let r = e.ok();
            if r.is_none() {
                eprintln!("Failed to parse: {:?}", &r);
            }
            r
        })
        .map(|e| e.match_string);
        let mut count = 0;
        let mut batch = WriteBatchWithTransaction::<false>::default();
        for item in w {
            let id = item.match_criteria_id;
            let i = item
                .matches
                .iter()
                .map(|e| e.cpe_name.as_str())
                .collect::<Rc<_>>()
                .encode::<u32>()
                .expect("failed to encode");
            count += 1;
            batch.put(id.as_bytes(), i);
        }
        self.db.write(batch)?;
        Ok(count)
    }

    fn set_last_update(&self, date: Option<&Date>, page: Option<u32>) {
        let mut f = File::options()
            .create(true)
            .write(true)
            .open(self.folder.to_string() + "/" + "cpes.json")
            .unwrap();
        let value = LastUdpateInfos::new(date, page);
        serde_json::to_writer_pretty(&f, &value).expect("failed to write db update");
        f.flush().expect("failed to flush file");
    }

    fn get_last_update(&self) -> (Option<Date>, Option<u32>) {
        let c = File::open(format!("{}/cpes.json", self.folder)).ok();
        if let Some(file) = c {
            let parsed: LastUdpateInfos = serde_json::from_reader(file).expect("failed to parse");
            let date = parsed.date.and_then(Date::from_timestamp_millis);
            return (date, parsed.page);
        }
        (None, None)
    }

    pub fn update_cpes(&self, mode: &ScrollMode, window: Option<Vec<Window>>) -> u32 {
        let last_update = self.get_last_update();
        let count = AtomicU32::new(0);
        match mode {
            ScrollMode::Page => {
                let page = last_update.1.unwrap_or(0);
                println!("Using page, starting at: {page}");
                // count += size;
                const size: u32 = 500;
                for index in self.do_pages(page) {
                    count.fetch_add(size, std::sync::atomic::Ordering::Relaxed);
                    self.db.flush().expect("failed to flush");
                    self.set_last_update(None, Some(index));
                }
            }
            ScrollMode::Date => {
                let d = last_update
                    .0
                    .unwrap_or(Utc.with_ymd_and_hms(1999, 1, 1, 0, 0, 0).unwrap());
                println!("making windows, starting at: {d}");
                let window_size = Duration::days(1);
                let windows = window.unwrap_or_else(|| get_windows_until_now(d, window_size));
                for w in windows {
                    let size = self.do_window(&w).expect("failed to do window");
                    self.db.flush().expect("failed to flush");
                    self.set_last_update(Some(&w.end), None);
                    println!("did {:?} of size: {}", w, &size);
                    count.fetch_add(size, std::sync::atomic::Ordering::Relaxed);
                }
            }
        }
        count.load(std::sync::atomic::Ordering::Relaxed)
    }
}
