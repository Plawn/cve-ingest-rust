use std::fs::File;

use std::rc::Rc;

use std::thread::sleep;
use std::time::Duration;

use chrono::TimeZone;
use chrono::Utc;

use rocksdb::WriteBatchWithTransaction;
use serde::Deserialize;
use serde::Serialize;

use crate::cves::get_windows_until_now;
use crate::cves::LastUdpateInfos;
use crate::cves::Window;
use crate::prepare_date;
use crate::windowed::UrlProvider;
use crate::windowed::Windower;

use crate::CveDb;
use crate::Date;
use bytevec::ByteEncodable;

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Root {
    pub results_per_page: i64,
    pub start_index: i64,
    pub total_results: i64,
    pub format: String,
    pub version: String,
    pub timestamp: String,
    pub match_strings: Vec<MatchString>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct MatchString {
    pub match_string: MatchString2,
}

impl UrlProvider for MatchString {
    fn url(start: Date, end: Date, index: u32) -> String {
        let url = format!(
            "https://services.nvd.nist.gov/rest/json/cpematch/2.0?lastModStartDate={}&lastModEndDate={}&startIndex={}", prepare_date(&start), prepare_date(&end), index);
        url
    }
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct MatchString2 {
    /// Index to use
    pub match_criteria_id: String,
    pub criteria: String,
    pub version_end_including: Option<String>,
    pub last_modified: String,
    pub cpe_last_modified: String,
    pub created: String,
    pub status: String,
    #[serde(default)]
    pub matches: Vec<Match>,
    pub version_end_excluding: Option<String>,
    pub version_start_including: Option<String>,
    pub version_start_excluding: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Match {
    pub cpe_name: String,
    pub cpe_name_id: String,
}

fn get_url(window: &Window, start_index: u32) -> String {
    // let url = "https://services.nvd.nist.gov/rest/json/cves/2.0/?lastModStartDate=2023-10-29T13:32:53.000%2B01:00&lastModEndDate=2023-10-29T21:32:53.000%2B01:00&startIndex=0";
    let url = format!(
        "https://services.nvd.nist.gov/rest/json/cpematch/2.0?lastModStartDate={}&lastModEndDate={}&startIndex={}", prepare_date(&window.start), prepare_date(&window.end), start_index);
    url
}

// https://services.nvd.nist.gov/rest/json/cpematch/2.0?lastModStartDate=2024-02-14T09:20:39.000%2B01:00&lastModEndDate=2024-02-13T09:20:39.000%2B01:00&startIndex=0
// https://services.nvd.nist.gov/rest/json/cpematch/2.0?lastModStartDate=2024-02-14T14:18:05.000%2B01:00&lastModEndDate=2024-02-13T14:18:05.000%2B01:00&startIndex=0
// https://services.nvd.nist.gov/rest/json/cpematch/2.0?lastModStartDate=2021-08-04T13:00:00.000%2B01:00&lastModEndDate=2021-10-22T13:36:00.000%2B01:00

fn get_responses(window: &Window) -> reqwest::blocking::Response {
    let url = get_url(window, 0);
    println!("{}", &url);
    loop {
        match reqwest::blocking::get(&url) {
            Ok(r) => {
                if r.status().is_success() {
                    break r;
                }
                println!("Got error: {} -> sleeping for 5 secs", r.status());
                sleep(Duration::from_secs(5));
            }
            Err(err) => {
                println!("sleeping for 5 sec: {}", err);
                sleep(Duration::from_secs(5));
            }
        }
    }
}

impl CveDb {
    fn do_window(&self, window: &Window) -> Result<u32, Box<dyn std::error::Error>> {
        let prefix = "matchStrings".as_bytes();
        let w = Windower::<'_, _, MatchString>::new(window.start, window.end, prefix)
            .map(|e| e.unwrap())
            .map(|e| e.match_string);
        let mut count = 0;
        let mut batch = WriteBatchWithTransaction::<false>::default();
        for item in w {
            let id = item.match_criteria_id;
            let i = item
                .matches
                .iter()
                .map(|e| e.cpe_name.as_str())
                .collect::<Rc<_>>()
                .encode::<u32>()
                .expect("failed to encode");
            count += 1;
            batch.put(id.as_bytes(), i);
        }
        self.db.write(batch)?;
        Ok(count)
    }

    fn set_last_update(&self, date: Date) {
        let f = File::options()
            .create(true)
            .write(true)
            .open(self.folder.to_string() + "/" + "cpes.json")
            .unwrap();
        serde_json::to_writer_pretty(f, &LastUdpateInfos::new(date))
            .expect("failed to write db update");
    }

    fn get_last_update(&self) -> Option<Date> {
        let c = File::open(self.folder.to_string() + "/" + "cpes.json").ok();
        if let Some(file) = c {
            let parsed: LastUdpateInfos = serde_json::from_reader(file).expect("failed to parse");
            return Date::from_timestamp_millis(parsed.date);
        }
        Option::None
    }

    pub fn update_cpes(&self, window: Option<Vec<Window>>) -> u32 {
        let last_update = self.get_last_update();
        let d = last_update.unwrap_or_else(|| Utc.with_ymd_and_hms(2019, 1, 1, 0, 0, 0).unwrap());
        println!("making windows, starting at: {d}");
        let windows = window.unwrap_or_else(|| get_windows_until_now(d));
        let mut count = 0;
        for w in windows {
            let size = self.do_window(&w).expect("failed to do window");
            self.set_last_update(w.start);
            println!("did {:?} of size: {}", w, &size);
            count += size;
        }
        count
    }
}
