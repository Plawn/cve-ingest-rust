use std::fs::File;
use std::io::BufReader;
use std::rc::Rc;
use std::str::FromStr;
use std::thread::sleep;
use std::time::Duration;

use chrono::Days;
use chrono::TimeZone;
use chrono::Utc;
use jsonit::make_prefix;
use jsonit::JsonSeqIterator;
use reqwest::Response;
use rocksdb::WriteBatchWithTransaction;
use serde::Deserialize;
use serde::Serialize;

use crate::cves::get_windows_until_now;
use crate::cves::LastUdpateInfos;
use crate::cves::Window;
use crate::prepare_date;
use crate::CpeMatch;
use crate::CveDb;
use crate::Date;
use bytevec::{ByteDecodable, ByteEncodable};

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Root {
    pub results_per_page: i64,
    pub start_index: i64,
    pub total_results: i64,
    pub format: String,
    pub version: String,
    pub timestamp: String,
    pub match_strings: Vec<MatchString>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct MatchString {
    pub match_string: MatchString2,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct MatchString2 {
    /// Index to use
    pub match_criteria_id: String,
    pub criteria: String,
    pub version_end_including: Option<String>,
    pub last_modified: String,
    pub cpe_last_modified: String,
    pub created: String,
    pub status: String,
    #[serde(default)]
    pub matches: Vec<Match>,
    pub version_end_excluding: Option<String>,
    pub version_start_including: Option<String>,
    pub version_start_excluding: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Match {
    pub cpe_name: String,
    pub cpe_name_id: String,
}

fn get_url(window: &Window, start_index: u32) -> String {
    // let url = "https://services.nvd.nist.gov/rest/json/cves/2.0/?lastModStartDate=2023-10-29T13:32:53.000%2B01:00&lastModEndDate=2023-10-29T21:32:53.000%2B01:00&startIndex=0";
    let url = format!(
        "https://services.nvd.nist.gov/rest/json/cpematch/2.0?lastModStartDate={}&lastModEndDate={}&startIndex={}", prepare_date(&window.start), prepare_date(&window.end), start_index);
    url
}

// https://services.nvd.nist.gov/rest/json/cpematch/2.0?lastModStartDate=2024-02-14T09:20:39.000%2B01:00&lastModEndDate=2024-02-13T09:20:39.000%2B01:00&startIndex=0
// https://services.nvd.nist.gov/rest/json/cpematch/2.0?lastModStartDate=2024-02-14T14:18:05.000%2B01:00&lastModEndDate=2024-02-13T14:18:05.000%2B01:00&startIndex=0
// https://services.nvd.nist.gov/rest/json/cpematch/2.0?lastModStartDate=2021-08-04T13:00:00.000%2B01:00&lastModEndDate=2021-10-22T13:36:00.000%2B01:00

fn get_resp(url: &str) -> reqwest::blocking::Response {
    loop {
        match reqwest::blocking::get(url) {
            Ok(r) => {
                if r.status() == 200 {
                    break r;
                }
                println!("Got rate limited {} -> sleeping for 5 secs", r.status());
                sleep(Duration::from_secs(5));
            },
            Err(_) => {
                println!("sleeping for 5 sec");
                sleep(Duration::from_secs(5));
            }
        }
    }
}

impl CveDb {
    fn do_window(&self, w: &Window) -> Result<(), Box<dyn std::error::Error>> {
        println!("window {:?}", &w);
        let url = get_url(w, 0);
        println!("{}", &url);
        let resp = get_resp(&url);
        
        let buf = BufReader::new(resp);
        // iter on response
        let prefix = make_prefix("matchStrings");
        let it = JsonSeqIterator::new(buf, &prefix).map(|e| e.unwrap());
        let mut batch = WriteBatchWithTransaction::<false>::default();
        for item in it.map(|e: MatchString| e.match_string) {
            let id = item.match_criteria_id;
            let i = item
                .matches
                .iter()
                .map(|e| e.cpe_name.as_str())
                .collect::<Rc<_>>()
                .encode::<u32>()
                .expect("failed to encode");
            let _ = &batch.put(id.as_bytes(), i);
        }
        let _ = self.db.write(batch);
        println!("did window");
        Ok(())
    }

    fn set_last_update(&self, date: Date) {
        let f = File::options().create(true).write(true).open(self.folder.to_string() + "/" + "cpes.json").unwrap();
        serde_json::to_writer_pretty(f, &LastUdpateInfos::new(date))
            .expect("failed to write db update");
    }

    fn get_last_update(&self) -> Option<Date> {
        let c = File::open(self.folder.to_string() + "/" + "cpes.json").ok();
        if let Some(file) = c {
            let parsed: LastUdpateInfos = serde_json::from_reader(file).expect("failed to parse");
            return Date::from_timestamp_millis(parsed.date);
        }
        Option::None
    }

    pub fn update_cpes(&self) {
        let last_update = self.get_last_update();
        let min = Utc.with_ymd_and_hms(1980, 1, 1, 0, 0, 0).unwrap();
        let d =
            last_update.unwrap_or_else(|| min);
        println!("making windows, starting at: {d}");
        let windows = get_windows_until_now(d);
        for w in windows {
            self.do_window(&w).expect("failed to do window");
            self.set_last_update(w.start);
            println!("did {:?}", w);
        }
        // get last date
        // for each windows
        // do window
        // update last update
        // todo!();
    }
}
