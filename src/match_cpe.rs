use std::fs::File;

use std::io::Write;
use std::rc::Rc;

use chrono::Duration;
use chrono::TimeZone;
use chrono::Utc;

use rocksdb::WriteBatchWithTransaction;
use serde::Deserialize;
use serde::Serialize;

use crate::cves::get_windows_until_now;
use crate::cves::LastUdpateInfos;
use crate::cves::Window;
use crate::prepare_date;
use crate::windowed::UrlProvider;
use crate::windowed::Windower;

use crate::CveDb;
use crate::Date;
use bytevec::ByteEncodable;

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Root {
    pub results_per_page: i64,
    pub start_index: i64,
    pub total_results: i64,
    pub format: String,
    pub version: String,
    pub timestamp: String,
    pub match_strings: Vec<MatchString>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct MatchString {
    pub match_string: MatchString2,
}

impl UrlProvider for MatchString {
    fn url(start: Date, end: Date, index: u32, api_key: &Option<String>) -> String {
        let url = format!(
            "https://services.nvd.nist.gov/rest/json/cpematch/2.0?lastModStartDate={}&lastModEndDate={}&startIndex={}", prepare_date(&start), prepare_date(&end), index);
        url
    }
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct MatchString2 {
    /// Index to use
    pub match_criteria_id: String,
    pub criteria: String,
    pub version_end_including: Option<String>,
    pub last_modified: String,
    pub cpe_last_modified: String,
    pub created: String,
    pub status: String,
    #[serde(default)]
    pub matches: Vec<Match>,
    pub version_end_excluding: Option<String>,
    pub version_start_including: Option<String>,
    pub version_start_excluding: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Match {
    pub cpe_name: String,
    pub cpe_name_id: String,
}

#[derive(Debug)]
pub enum ScrollMode {
    Page, Date
}

impl CveDb {
    fn do_window(&self, window: &Window) -> Result<u32, Box<dyn std::error::Error>> {
        let prefix = "matchStrings".as_bytes();
        let size_hint = Some(500);
        let w = Windower::<'_, _, MatchString>::new(
            window.start,
            window.end,
            prefix,
            None, // TODO: add api_key support
            size_hint,
        )
        .filter_map(|e| {
            let r = e.ok();
            if r.is_none() {
                eprintln!("Failed to parse: {:?}", &r);
            }
            r
        })
        .map(|e| e.match_string);
        let mut count = 0;
        let mut batch = WriteBatchWithTransaction::<false>::default();
        for item in w {
            let id = item.match_criteria_id;
            let i = item
                .matches
                .iter()
                .map(|e| e.cpe_name.as_str())
                .collect::<Rc<_>>()
                .encode::<u32>()
                .expect("failed to encode");
            count += 1;
            batch.put(id.as_bytes(), i);
        }
        self.db.write(batch)?;
        Ok(count)
    }

    fn set_last_update(&self, date: &Date) {
        let mut f = File::options()
            .create(true)
            .write(true)
            .open(self.folder.to_string() + "/" + "cpes.json")
            .unwrap();
        serde_json::to_writer_pretty(&f, &LastUdpateInfos::new(date))
            .expect("failed to write db update");
        f.flush().expect("failed to flush file");
    }

    fn get_last_update(&self) -> Option<Date> {
        let c = File::open(format!("{}/cpes.json", self.folder)).ok();
        if let Some(file) = c {
            let parsed: LastUdpateInfos = serde_json::from_reader(file).expect("failed to parse");
            return Date::from_timestamp_millis(parsed.date);
        }
        Option::None
    }

    pub fn update_cpes(&self, 
        mode: ScrollMode,
        window: Option<Vec<Window>>
    ) -> u32 {
        match mode {
            ScrollMode::Page => todo!(),
            ScrollMode::Date => {
                let last_update = self.get_last_update();
                let d = last_update.unwrap_or_else(|| Utc.with_ymd_and_hms(1999, 1, 1, 0, 0, 0).unwrap());
                println!("making windows, starting at: {d}");
                let window_size = Duration::days(1);
                let windows = window.unwrap_or_else(|| get_windows_until_now(d, window_size));
                let mut count = 0;
                for w in windows {
                    let size = self.do_window(&w).expect("failed to do window");
                    self.db.flush().expect("failed to flush");
                    self.set_last_update(&w.end);
                    println!("did {:?} of size: {}", w, &size);
                    count += size;
                }
                count
            },
        }

    }
}
