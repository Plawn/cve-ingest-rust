use std::{
    fs::{self, File},
    io::{BufRead, BufReader, Seek, Write},
};

use crate::{CveDb, CVE};

impl CveDb {
    pub fn get_cve(self, cve_name: &str) -> Option<CVE> {
        let year = cve_name.split('-').nth(1).expect("malformed cve name");
        let p = self.folder.to_string() + "/cves/" + &year + "/" + cve_name;
        let f = File::open(p).ok();
        if let Some(file) = f {
            let cve: CVE = serde_json::from_reader(file).expect("Invalid cve");
            return Some(cve);
        }
        Option::None
    }

    pub fn write_cve(self, cve: &CVE) {
        let p = self.folder.to_string() + "/" + &cve.id;
        let f = File::options().write(true).open(p).ok();
        if let Some(mut file) = f {
            file.write(&serde_json::to_vec(cve).expect("failed to serialyze"))
                .expect("failed to write");
        }
    }

    pub fn iter_cves(&self) -> impl Iterator<Item = CVE> + '_ {
        let paths = fs::read_dir(self.folder.to_string() + "/cves").unwrap();
        paths
            .into_iter()
            .map(|e| e.unwrap())
            .filter(|e| e.path().is_file())
            .map(|e| e.file_name().to_str().unwrap().to_owned())
            .map(move |e| (*self).clone().get_cve(&e))
            .map(|e| e.unwrap())
    }

    pub fn bind(&self) {
        // for each cve
        self.iter_cves().for_each(|cve| {
            // get cpes
            cve.vulnerable_configuration.iter().for_each(|cpe| {
                // split cpe
                // get product
                // get version
                // get vendor
                // write a file
                // for each line -> cve | cpes qui ont permis de faire cette lignep
                let (product, version, vendor) = split_cpe(cpe);
                // will write at
                let to_write = cve.id.to_string() + " " + &vendor;
                let base_folder = self.folder.to_string() + "/product/" + &product + "/";
                fs::create_dir_all(&base_folder).expect("failed to create sub dirs");
                let extension = ".cves-vendor";
                let path = base_folder + &version + extension;
                let mut f = File::options()
                    .write(true)
                    .read(true)
                    .create(true)
                    .open(path)
                    .expect("failed to open");
                let reader = BufReader::new(&f);
                let mut requires_write = true;
                let mut current = reader
                    .lines()
                    .map(|e| {
                        let r = e.unwrap();
                        if to_write == r {
                            requires_write = false;
                        }
                        (r + "\n").as_bytes().to_owned()
                    })
                    .collect::<Vec<_>>();
                if requires_write {
                    current.push(to_write.as_bytes().to_owned());
                }
                current.sort();
                // seek start of file to rewrite everything in order
                f.seek(std::io::SeekFrom::Start(0)).expect("failed to seek");
                let _ = f.write(&current.concat());
            })
        });
    }
}

type Product = String;
type Version = String;
type Vendor = String;

fn split_cpe(cpe: &str) -> (Product, Version, Vendor) {
    let mut s = cpe.split(':');
    // cpe:2.3:a:busybox:busybox:1.18.3:*:*:*:*:*:*:*
    let vendor: Product = s.nth(3).unwrap().into();
    let product = s.next().unwrap().into();
    let version = s.next().unwrap().into();
    (product, version, vendor)
}
