use std::{
    any::Any,
    fs::{self, File},
    io::{BufRead, BufReader, Seek, Write},
    sync::Arc,
};

use itertools::Itertools;

use crate::CVE;

#[derive(Clone)]
pub struct CveDb {
    folder: Arc<str>,
}

impl CveDb {
    pub fn from(folder: &str) -> Self {
        Self {
            folder: folder.into(),
        }
    }

    pub fn get_cve(self, cve_name: &str) -> Option<CVE> {
        let p = self.folder.to_string() + "/" + cve_name;
        println!("reading  {cve_name}");
        let f = File::open(p).ok();
        if let Some(file) = f {
            let cve: CVE = serde_json::from_reader(file).expect("Invalid cve");
            return Some(cve);
        }
        Option::None
    }

    pub fn write_cve(self, cve: &CVE) {
        let p = self.folder.to_string() + "/" + &cve.id.to_string();
        let f = File::options().write(true).open(p).ok();
        if let Some(mut file) = f {
            file.write(&serde_json::to_vec(cve).expect("failed to serialyze"))
                .expect("failed to write");
        }
    }

    pub fn iter_cves(&self) -> impl Iterator<Item = CVE> + '_ {
        let paths = fs::read_dir(self.folder.to_string()).unwrap();
        paths
            .into_iter()
            .map(|e| e.unwrap())
            .filter(|e| e.path().is_file())
            .map(|e| e.file_name().to_str().unwrap().to_owned())
            .map(move |e| (*self).clone().get_cve(&e))
            .map(|e| e.unwrap())
    }

    pub fn bind(&self) {
        // for each cve
        self.iter_cves().for_each(|cve| {
            // get cpes
            cve.vulnerable_configuration.iter().for_each(|cpe| {
                // split cpe
                // get product
                // get version
                // get vendor
                // write a file
                // for each line -> cve | cpes qui ont permis de faire cette lignep
                let (product, version, vendor) = split_cpe(cpe);
                // will write at
                let to_write = cve.id.to_string() + " " + &vendor;
                let base_folder = self.folder.to_string() + "/product/" + &product + "/";
                fs::create_dir_all(&base_folder).expect("failed to create sub dirs");
                let path = base_folder + &version + ".cves-vendor";
                println!("want to write {}", &path);
                let mut f = File::options()
                    .write(true)
                    .read(true)
                    .create(true)
                    .open(path)
                    .expect("failed to open");
                let reader = BufReader::new(&f);
                let mut requires_write = true;
                let mut current = reader
                    .lines()
                    .map(|e| {
                        let r = e.unwrap();
                        println!("{} == {} -> {}", to_write, r, to_write == r);
                        if to_write == r {
                            println!("setting to false");    
                            requires_write = false;
                        }
                        (r +"\n").as_bytes().to_owned()
                    })
                    .collect::<Vec<_>>();
                if requires_write {
                    println!("adding because {}", requires_write);
                    current.push(to_write.as_bytes().to_owned());
                }
                current.sort();
                f.seek(std::io::SeekFrom::Start(0));
                let _ = f.write(&current.concat());
            })
        });
    }
}

type Product = String;
type Version = String;
type Vendor = String;

fn split_cpe(cpe: &str) -> (Product, Version, Vendor) {
    let mut s = cpe.split(":");
    // cpe:2.3:a:busybox:busybox:1.18.3:*:*:*:*:*:*:*
    let vendor: Product = s.nth(3).unwrap().into();
    let product = s.nth(0).unwrap().into();
    let version = s.nth(0).unwrap().into();
    return (product, version, vendor);
}
